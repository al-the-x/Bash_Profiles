alias j='jobs'
alias .f='dotfiles'

alias vimrc="vim -c '"'edit $MYVIMRC'"'"
alias vims="vim -S"
alias zshalias="vim ~/.zshalias && source ~/.zshalias"
alias grepc="grep --color=always"

alias today='gdate -d today -I'
alias yesterday='gdate -d yesterday -I'
alias tomorrow='gdate -d tomorrow -I'

## From `brew install hub`
alias gpr='git pull-request'

## From `brew install git extras`
alias gwi='git ignore'
alias gbp='git-delete-merged-branches'

## Replacing `git ll` and `git la`...
alias gll='git log --graph --pretty=format:"${_git_log_oneline_format}"'
alias gla='gll --all'

## From `brew install `hub`...
alias ggo='git browse'

## Missing from Prezto?
alias gwm='git mv'
alias gwM='git mv --force'

## Application shortcuts...

## Find WTF this command is... with regex!
## b/c prezto ships with too many dang aliases to remember them all...
function wtf {
  alias | grep $@
}


## Exec the `node` repl with `rlwrap` if available...
function node {
  [[ $# -eq 0 ]] && whence rlwrap &> /dev/null && {
    NODE_NO_READLINE=1 rlwrap node
  } || node "$@"
}

##
# My primary CASTLE is named `dotfiles`
##
function dotfiles {
  [ $# -ge 1 ] || {
    cat >&2 <<'USAGE'
  usage: dotfiles COMMAND [options]

    Proxy for `homesick COMMAND dotfiles [options]`
USAGE

    homesick --help; return 1
  }

  CMD="$1"; shift
  homesick $CMD dotfiles $@
}

##
# Create a new `vim` session tracked with `:Obsession`
##
function vim-session {
  SESSION="$1"; shift

  ##
  # I'm not entirely certain that `vim-obsession` will start tracking just
  # because a session is started, but we'll see...
  ##
  vim -S "$SESSION" -c "Obsession $SESSION" $@
}

##
# Create or open a `vim-session` named like `git-branch-current` and stored in
# a directory named `.vim/` at the root of the work-tree.
##
function vim-session-branch {
  vim-session "$(git-root)/.vim/$(git-branch-current).vim" $@
}

##
# Create a new branch and open a `vim-session-branch` for it
##
function git-branch-session {
  { git checkout $1 || git checkout -b $1 } && vim-session-branch
}

##
# Print all the lines between two markers or that appear _after_ one marker
#
# TODO: Move into an autoloading function
##
function between {
  if [ $# -lt 1 ]; then
    cat <<'USAGE'
  usage: between START END

    Print input from `stdin` that appears between `START`
    and `END` markers, as long as they appear on a single
    line.

    EXAMPLE

    $> between.zsh | between USAGE EXAMPLE
      usage: between START END

        Print input from `stdin` that appears between `START`
        and `END` markers, as long as they appear on a single
        line.
USAGE

    return 1
  fi
  if [ $# -gt 1 ]; then
    gawk "/${1}/{keep=1}/${2}/{keep=0} keep"
  else
    gawk "/${1}/{keep=1}keep"
  fi
} ## END between

## Print a random line from a file...
## TODO: Move into an autoloading function
function randline {
  integer lines=$(wc -l <$1)
  sed -n $[RANDOM % lines + 1]p $1
} ## END randline


## Fixup the SSH environment variables inside tmux...
### TODO: Move into an autoloading function
function ssh-fix {
  [[ -n "$TMUX" && -n "$SSH_CONNECTION" ]] && {
    eval "$(tmux showenv | grep -v '^-' | sed -e 's/=\(.*\)/="\1"/' -e 's/^/export /')"
  }
}
